<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Piano Editor</title>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <style>
      textarea {
        width: 50vh;
        height: 60vh;
        font-family: monospace;
        font-size: 16px;
      }
    </style>
  </head>
  <body>
    <div style="display: flex; flex-direction: row; gap: 20px">
      <div>
        <h1>Piano Editor</h1>
        <button id="resetBtn">Reset</button>
        <span id="status">Ready to play</span>
        <br /><br />
        <textarea
          id="text"
          placeholder="Press any key to play the next note..."
        >
function setup() {
  createCanvas(400, 400);
  background(220);
}</textarea
        >
      </div>
      <div id="iframe-container"></div>
    </div>
    <script>
      // Global variables
      let currentNoteIndex = 0;
      let musicData = null;
      let synth = null;
      let noteQueue = [];
      let isPlaying = false;
      let playTimeout = null;

      // Initialize Tone.js and load music data
      async function init() {
        try {
          // Load the music data
          const response = await fetch("beethoven_moonlight.json");
          musicData = await response.json();

          // Create a simple, quick piano sound
          synth = new Tone.PolySynth(Tone.Synth, {
            oscillator: {
              type: "triangle",
            },
            envelope: {
              attack: 0.01,
              decay: 0.1,
              sustain: 0.2,
              release: 0.3,
            },
          }).toDestination();

          console.log("Music data loaded:", musicData);
          updateStatus("Ready to play - Press any key to play next note!");
        } catch (error) {
          console.error("Error loading music data:", error);
          updateStatus("Error loading music data");
        }
        updateIframe();
      }

      // Queue a note to be played
      function queueNote() {
        if (!musicData || currentNoteIndex >= musicData.pieceData.length) {
          if (currentNoteIndex >= musicData.pieceData.length) {
            updateStatus("End of piece! Press Reset to start over.");
          }
          return;
        }

        // Get the current note data
        const noteData = musicData.pieceData.slice(
          currentNoteIndex,
          currentNoteIndex + 4
        );
        if (noteData.length < 4) return;

        const [time, velocity, note, duration] = noteData;

        // Add note to queue with shorter duration
        noteQueue.push({
          frequency: Tone.Frequency(note, "midi").toFrequency(),
          duration: 0.2, // Fixed short duration
          velocity: velocity / 127,
        });

        // Move to next note
        currentNoteIndex += 4;

        // Update status
        updateStatus(
          `Queued ${noteQueue.length} notes - Note ${Math.floor(
            currentNoteIndex / 4
          )} of ${Math.floor(musicData.pieceData.length / 4)}`
        );

        // Start playing if not already playing
        if (!isPlaying) {
          playNextQueuedNote();
        }
      }

      // Play the next note from the queue
      function playNextQueuedNote() {
        if (noteQueue.length === 0) {
          isPlaying = false;
          return;
        }

        if (!synth) return;

        isPlaying = true;
        const note = noteQueue.shift();

        // Play the note
        synth.triggerAttackRelease(
          note.frequency,
          note.duration,
          Tone.now(),
          note.velocity
        );

        // Schedule next note with faster delay
        playTimeout = setTimeout(() => {
          playNextQueuedNote();
        }, 150); // 150ms delay between notes (faster)
      }

      // Reset to beginning
      function resetPlayback() {
        currentNoteIndex = 0;
        noteQueue = [];
        isPlaying = false;
        if (playTimeout) {
          clearTimeout(playTimeout);
          playTimeout = null;
        }
        updateStatus("Ready to play - Press any key to play next note!");
      }

      // Update status display
      function updateStatus(message) {
        const statusEl = document.getElementById("status");
        statusEl.textContent = message;
      }

      // Event listeners
      document.getElementById("text").addEventListener("keydown", (e) => {
        // Start audio context if not already started
        if (Tone.context.state !== "running") {
          Tone.start();
        }
        queueNote();

        if (e.metaKey && e.key === "s") {
          e.preventDefault();
          updateIframe();
        }
      });

      document
        .getElementById("resetBtn")
        .addEventListener("click", resetPlayback);

      function updateIframe() {
        const iframeEl = document.getElementById("iframe-container");
        iframeEl.innerHTML = "";
        const iframe = document.createElement("iframe");
        iframe.src = "sketch.html?code=" + encodeURIComponent(text.value);
        iframe.style.width = "60vw";
        iframe.style.height = "100vh";
        iframe.style.border = "1px solid #ccc";
        iframeEl.appendChild(iframe);
      }
      init();
    </script>
  </body>
</html>
